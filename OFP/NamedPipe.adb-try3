
with ExecItf;
with Interfaces.C;
with NamedPipeNames;
with Remote;
with System;
with Text_IO;
with Unchecked_Conversion;

package body NamedPipe is

  package Int_IO is new Text_IO.Integer_IO( Integer );

  function AddrToLPSCSTR -- convert address to ExecItf pointer
  is new Unchecked_Conversion( Source => System.Address,
                               Target => ExecItf.LPCSTR );
  function toLPDWORD -- convert address to Exec_Itf pointer
  is new Unchecked_Conversion( Source => System.Address,
                               Target => ExecItf.LPDWORD );
  function toLPVOID -- convert address to Exec_Itf pointer
  is new Unchecked_Conversion( Source => System.Address,
                               Target => ExecItf.LPVOID );

--  type FullPipeName is new String(1..14);
  type FullPipeName is new String(1..16);

  -- Information about a thread and Microsoft Windows named pipes
  type CommunicationInfoType
  is record
    Name      : FullPipeName; --NamedPipeNames.PipeNameType;--String(1..4); -- must be of the form \\.\pipe\pipename
    -- Name of pipe
    Key       : Itf.ParticipantKeyType;
    -- Key of associated Receive or Transmit component where the local
    -- application is the pipe server
    Created   : Boolean;
    -- Whether pipe between server and client has been created
    Connected : Boolean;
    -- Whether pipe between server and client has connected
    Failed    : Boolean;
    Handle    : ExecItf.HANDLE;
    -- Pipe handle
  end record;

  type CommunicationInfoArrayType
  is array (1..2) of CommunicationInfoType;
--<<< change this array to be over PipeDirectionType? Then Receive Index is 0
--    and Transmit Index is 1 but would use Receive and Transmit as the index.>>>

  PipeInfo : CommunicationInfoArrayType; --  = new CommunicationInfoType[2];

  NullPipeInfo
  : constant CommunicationInfoType
  := ( Name      => --('\','\','.','\','p','i','p','e','\','a','p','p',' ','M','t','o','N',others=>ASCII.Nul),
                    ('\','\','.','\','p','i','p','e','\','P','M','t','o','N',others=>ASCII.NUL),
       Key       => (0,0,0),
       Created   => False,
       Connected => False,
       Failed    => False,
       Handle    => System.Null_Address
     );


--  PipeServer : NamedPipeServerStream := null;
--  PipeClient : NamedPipeClientStream := null;
--  PipeServer : ExecItf.HANDLE; -- Transmit
--  PipeClient : ExecItf.HANDLE; -- Receive

  -- Information about a thread and Microsoft Windows named pipes
--  type CommunicationInfoType
--  is record
--    Name      : NamedPipeNames.PipeNameType;--String(1..4); -- must be of the form \\.\pipe\pipename
    -- Name of pipe
--    Created   : Boolean;
    -- Whether pipe between server and client has been created
--    Connected : Boolean;
    -- Whether pipe between server and client has connected
--    Failed    : Boolean;
--  end record;

  -- Application identifier of the associated remote application
  LocalAppId  : Itf.Int8;
  RemoteAppId : Itf.Int8;
  TransmitIndex : Integer; -- of pipePair
  ReceiveIndex  : Integer; -- of pipePair

--  nPN : NamedPipeNames.NamedPipeNameType; -- := new NamedPipeNames;
  PipePair : NamedPipeNames.NamedPipeNameType;

--  type CommunicationInfoArrayType
--  is array (1..2) of CommunicationInfoType;

--  PipeInfo : CommunicationInfoArrayType; --  = new CommunicationInfoType[2];

--  function OpenReceivePipe
--  return Boolean;
-- moved to spec 

  function ReceiveMessage
  return Itf.BytesType;

  procedure TransmitMessage
  ( Message : in Itf.BytesType
  );

--  type ReceiveOpenCallbackType
  -- Callback to open a receive pipe
--  is access procedure
--  ( RemoteAppId : in Itf.Int8
    -- Receive pipe to be opened
--  );
--  type ReceiveCallbackType
  -- Callback to execute receive message to be transmitted
--  is access procedure
--  ( Message : out Itf.BytesType
    -- Received Message to be returned
--  );
--  type TransmitCallbackType
  -- Callback to execute receive message to be transmitted
--  is access procedure
--  ( Message : in Itf.BytesType
    -- Message to be transmitted
--  );

  function toOpenReceive is new Unchecked_Conversion
                                ( Source => System.Address,
                                  Target => Itf.ReceiveOpenCallbackType );
  function toReceive is new Unchecked_Conversion
                            ( Source => System.Address,
                              Target => Itf.ReceiveCallbackType );
  function toTransmit is new Unchecked_Conversion
                             ( Source => System.Address,
                               Target => Itf.TransmitCallbackType );

  procedure Initialize
  ( LocalId  : in Itf.Int8;
 --   RemoteId : Itf.Int8;
 --   Index    : Integer
    OpenReceive : out Itf.ReceiveOpenCallbackType;
    Receive     : out Itf.ReceiveCallbackType;
    Transmit    : out Itf.TransmitCallbackType
  ) is

  begin -- Initialize

    -- Save identifier of the remote application tied to this
    -- instance of the Receive class.
    LocalAppId := LocalId;
    RemoteAppId := RemoteId;

    TransmitIndex := 1; -- transmit
    ReceiveIndex  := 2; -- receive

--    PipePair := nPN.NamedPipeName.List(Index);
    PipePair := NamedPipeNames.NamedPipeName.List(Index);
--            Console.WriteLine("index {0}", index);
--Console.WriteLine("local pipe {0}",pipePair.lPipeName);
--Console.WriteLine("remote pipe {0}",pipePair.rPipeName);

    PipeInfo(TransmitIndex) := NullPipeInfo;
    PipeInfo(ReceiveIndex)  := NullPipeInfo;

    for I in 1..4 loop
      -- PipeInfo(LocalIndex).Name(10..13) := PipePair.lPipeName(1..4);
--      PipeInfo(TransmitIndex).Name(I+9) := PipePair.lPipeName(I);
      PipeInfo(TransmitIndex).Name(I+10) := PipePair.lPipeName(I);
    end loop;
    PipeInfo(TransmitIndex).Key := TransmitKey;
--    PipeInfo(LocalIndex).Created   := False;
--    PipeInfo(LocalIndex).Connected := False;
--    PipeInfo(LocalIndex).Failed := False;

--    PipeInfo(RemoteIndex).Name(10..13) := PipePair.rPipeName;
    for I in 1..4 loop
--      PipeInfo(ReceiveIndex).Name(I+9) := PipePair.rPipeName(I);
      PipeInfo(ReceiveIndex).Name(I+10) := PipePair.rPipeName(I);
    end loop;
    PipeInfo(ReceiveIndex).Key := ReceiveKey;
--    PipeInfo(RemoteIndex).Created   := False;
--    PipeInfo(RemoteIndex).Connected := False;
--    PipeInfo(RemoteIndex).Failed := False;

    OpenReceive := toOpenReceive(OpenReceivePipe'Address);
    Receive  := toReceive( ReceiveMessage'Address);
    Transmit := toTransmit( TransmitMessage'Address );

    Delay(2.000); -- 2 seconds

  end Initialize;

  function Connect
  ( Index     : in Integer; -- LocalIndex or RemoteIndex
    Direction : in PipeDirectionType
  ) return Boolean is

    Handle
    -- Handle of pipe
    : ExecItf.HANDLE;

    Status
    -- True means server connected to client
    : ExecItf.BOOL;

    use type ExecItf.BOOL;

  begin -- Connect

    -- Wait for the client to connect.  If it succeeds, the function returns
    -- a nonzero value.  If the function returns zero, GetLastError returns
    -- ERROR_PIPE_CONNECTED.

    if Direction = Transmit then
      Handle := PipeInfo(TransmitIndex).Handle;
    else
      Handle := PipeInfo(ReceiveIndex).Handle;
    end if;
--<<< change to put Handle in PipeInfo? >>>

    Status := ExecItf.ConnectNamedPipe
              ( NamedPipe  => Handle, --Comm.Pipe(Index)(Direction).Handle,
                Overlapped => null );
    if Status = 0 then -- FALSE
--      Display_Last_Error;
--      if String_Tools.Blind_Compare
--         ( Left  => "ERROR_PIPE_CONNECTED",
--           Right => Error_Text(1..Integer(Error_Text_Chars)) ) = String_Tools.Equal
--    then
      PipeInfo(Index).Connected := False;
    else -- TRUE
      PipeInfo(Index).Connected := True;
    end if;

    return PipeInfo(Index).Connected;

  end Connect;

  function PipeConnected
  ( Direction : in PipeDirectionType
  ) return Boolean is

    use type System.Address;

  begin -- PipeConnected

    if Direction = Receive then
      if PipeInfo(ReceiveIndex).Handle /= ExecItf.Invalid_Handle_Value and then
         PipeInfo(ReceiveIndex).Connected
      then
        return True;
      end if;
    else
      if PipeInfo(TransmitIndex).Handle /= ExecItf.Invalid_Handle_Value and then
         PipeInfo(TransmitIndex).Connected
      then
        return True;
      end if;
    end if;
    return False;
  end PipeConnected;

  -- Close the Receive and Transmit pipes
  procedure ClosePipes
  ( Client : in Boolean
  ) is

    Status
    -- True means function was successful
    : ExecItf.BOOL;

    use type System.Address;

  begin -- ClosePipes

    if Client then
      if PipeInfo(ReceiveIndex).Handle /= ExecItf.Invalid_Handle_Value then
        Text_IO.Put_Line("ClosePipes closing pipeClient and setting to null");
        Status := ExecItf.DisconnectNamedPipe
                  ( NamedPipe => PipeInfo(ReceiveIndex).Name'Address );
        PipeInfo(ReceiveIndex).Handle := System.Null_Address;
      end if;
    else
      if PipeInfo(TransmitIndex).Handle /= ExecItf.Invalid_Handle_Value then
        Text_IO.Put_Line("ClosePipes closing pipeServer and setting to null");
 --       PipeServer.Close;
        Status := ExecItf.DisconnectNamedPipe
                  ( NamedPipe => PipeInfo(TransmitIndex).Name'Address );
        PipeInfo(TransmitIndex).Handle := System.Null_Address;
      end if;
    end if;

  end ClosePipes;

  -- Open the Receive Pipe
  function OpenReceivePipe
  return Boolean is

    Connected : Boolean;

    use type Interfaces.C.unsigned_long;
    use type System.Address;

  begin -- OpenReceivePipe

    Text_IO.Put("OpenReceivePipe ");
    Text_IO.Put_Line(String(PipeInfo(ReceiveIndex).Name));
    if not PipeInfo(ReceiveIndex).Created then

--    PipeClient :=
--                new NamedPipeClientStream(".", PipeInfo(2).Name, --index].name,
--                                          PipeDirection.InOut, PipeOptions.None,
--                                          TokenImpersonationLevel.Impersonation);
      PipeInfo(ReceiveIndex).Handle :=
--        ExecItf.CreateFile
--        ( FileName            => AddrToLPSCSTR(PipeInfo(ReceiveIndex).Name'Address),
--          DesiredAccess       => ExecItf.GENERIC_READ or ExecItf.GENERIC_WRITE,
--          ShareMode           => 0, -- no sharing
--          SecurityAttributes  => null, -- default security attributes
--          CreationDisposition => ExecItf.OPEN_ALWAYS, --OPEN_EXISTING,
--          FlagsAndAttributes  => 0, -- default attributes
--          TemplateFile        => System.Null_Address -- no template
--        );
        ExecItf.CreateNamedPipe
        ( Name               => AddrtoLPSCSTR(PipeInfo(ReceiveIndex).Name'Address),
          OpenMode           => ExecItf.PIPE_ACCESS_DUPLEX,        --16#00000003#, -- Duplex
          PipeMode           => ExecItf.PIPE_TYPE_MESSAGE     or   --16#00000004#
                                ExecItf.PIPE_READMODE_MESSAGE or   --2 (0 is BYTE)
                                ExecItf.PIPE_WAIT,                 --0
          MaxInstances       => ExecItf.PIPE_UNLIMITED_INSTANCES,  --255 (16#00000000# is stream of bytes?)
          OutBufferSize      => Interfaces.C.unsigned_long(Itf.MessageSize), -- output buffer size
          InBufferSize       => Interfaces.C.unsigned_long(Itf.MessageSize), -- input buffer size
          DefaultTimeOut     => 0,           -- client timeout in msec
          SecurityAttributes => null );      -- default priority attributes --LPSECURITY_ATTRIBUTES

      -- Note: The client and server processes in this example are intended
      -- to run on the same computer, so the server name provided to the
      -- NamedPipeClientStream object is ".". If the client and server
      -- processes were on separate computers, "." would be replaced with
      -- the network name of the computer that runs the server process.
--<<< must fix the name in PipeInfo for use by ExecItf >>>

      if PipeInfo(ReceiveIndex).Handle = ExecItf.Invalid_Handle_Value then
        Text_IO.Put_Line("ERROR: PipeClient has become null");

      else

        Text_IO.Put_Line("Connecting to server...");
        begin
--        PipeClient.Connect; -- wait for 500 msec
          Connected := Connect( ReceiveIndex, Receive );
        exception
          when others => null;
        end;
        Text_IO.Put("PipeClient setting Connected ");
        Int_IO.Put(Integer(RemoteAppId));
        Text_IO.Put_Line("");

        if PipeInfo(ReceiveIndex).Handle = ExecItf.Invalid_Handle_Value then
          Text_IO.Put_Line("ERROR: PipeClient has become null");
        else
          PipeInfo(ReceiveIndex).Connected := True;
          Text_IO.Put("PipeClient Connected ");
          if PipeInfo(ReceiveIndex).Connected then
            Text_IO.Put("True ");
          else
            Text_IO.Put("False ");
          end if;
          Int_IO.Put(Integer(RemoteAppId));
          Text_IO.Put_Line(" ");
        end if;
        Remote.SetConnected( RemoteAppId, True );

      end if;

    end if;

    return PipeInfo(ReceiveIndex).Connected;

  end OpenReceivePipe;

  -- Open the Transmit Pipe
  function OpenTransmitPipe
  return Boolean is

    use type Interfaces.C.unsigned_long;
    use type NamedPipeNames.PipeNameType;
    use type System.Address;

  begin -- OpenTransmitPipe

    Text_IO.Put("OpenTransmitPipe ");
    Text_IO.Put_Line(String(PipeInfo(TransmitIndex).Name));
--    PipeServer :=
--          new NamedPipeServerStream(PipeInfo(1).Name, PipeDirection.InOut, 1);
    if PipeInfo(TransmitIndex).Name /= "" then
      PipeInfo(TransmitIndex).Handle :=
--        ExecItf.CreateFile
--        ( FileName            => AddrToLPSCSTR(PipeInfo(TransmitIndex).Name'address),
--          DesiredAccess       => ExecItf.GENERIC_READ or ExecItf.GENERIC_WRITE,
--          ShareMode           => 0, -- no sharing --16#00000003#, --share read (01) and write (10) access
--          SecurityAttributes  => null, -- default security attributes --LPSECURITY_ATTRIBUTES
--          CreationDisposition => ExecItf.OPEN_EXISTING, --3 where 4 is OPEN_ALWAYS, create if doesn't exist
--          FlagsAndAttributes  => 0, -- default attributes  --16#40000000#, --FILE_FLAG_OVERLAPPED
--          TemplateFile        => System.Null_Address ); -- no template file
      ExecItf.CreateNamedPipe
      ( Name               => AddrtoLPSCSTR(PipeInfo(ReceiveIndex).Name'Address),
        OpenMode           => ExecItf.PIPE_ACCESS_DUPLEX,        --16#00000003#, -- Duplex
        PipeMode           => ExecItf.PIPE_TYPE_MESSAGE     or   --16#00000004#
                              ExecItf.PIPE_READMODE_MESSAGE or   --2 (0 is BYTE)
                              ExecItf.PIPE_WAIT,                 --0
        MaxInstances       => ExecItf.PIPE_UNLIMITED_INSTANCES,  --255 (16#00000000# is stream of bytes?)
        OutBufferSize      => Interfaces.C.unsigned_long(Itf.MessageSize), -- output buffer size
        InBufferSize       => Interfaces.C.unsigned_long(Itf.MessageSize), -- input buffer size
        DefaultTimeOut     => 0,           -- client timeout in msec
        SecurityAttributes => null );      -- default priority attributes --LPSECURITY_ATTRIBUTES

      if PipeInfo(TransmitIndex).Handle /= ExecItf.Invalid_Handle_Value then

        PipeInfo(TransmitIndex).Created := True;

        -- Wait for a client to connect
 --       PipeServer.WaitForConnection;

        Text_IO.Put("Server connected for remote app ");
        Text_IO.Put_Line(String(PipeInfo(TransmitIndex).Name));

      end if;

      return PipeInfo(TransmitIndex).Created;

    else -- error creating pipe

        -- close the handle -- first check if pipeServer is non null
      return False;
    end if;

  end OpenTransmitPipe;

  -- Receive a message from the remote pipe client.
--  procedure ReceiveMessage
--  ( Message : out Itf.ByteArray --     public byte[] ReceiveMessage()
  function ReceiveMessage
  return Itf.BytesType is

    use type ExecItf.BOOL;
    use type Itf.Byte;
    use type Itf.BytesType;
    use type System.Address;

  begin -- ReceiveMessage

    if PipeInfo(ReceiveIndex).Handle /= ExecItf.Invalid_Handle_Value then

      Text_IO.Put("ReceiveMessage fromServer ");
      Int_IO.Put(Integer(RemoteAppId));
      if Remote.RemoteConnected(RemoteAppId) then--.PipeConnected then
        Text_IO.Put_Line(" True");
      else
        Text_IO.Put_Line(" False");
      end if;

 --               if (pipeClient.IsConnected)
 --               if ((pipeClient.IsConnected) && (pipeInfo[1].connected))
 --     if PipeClient.IsConnected and then

--          FromServer := ss.ReadBytes;
      if PipeInfo(ReceiveIndex).Connected and then
         Remote.RemoteConnected(RemoteAppId) --.PipeConnected
      then
        declare

          BytesToRead : Interfaces.C.unsigned_long;
          BytesRead   : Integer;
          Start       : Integer;
          FromServer  : Itf.BytesType;
          Status      : ExecItf.BOOL;

--          use type Itf.Int16;
        begin
          BytesToRead := Interfaces.C.unsigned_long(FromServer.Bytes'Last);
          Int_IO.Put(Integer(FromServer.Bytes'Last)); -- be sure this is 250
          Text_IO.Put_Line(" ");
          Status :=
            ExecItf.ReadFile
            ( File                => PipeInfo(ReceiveIndex).Handle, -- handle to pipe
              Buffer              => toLPVOID(FromServer.Bytes'address), -- buffer to receive data
              NumberOfBytesToRead => BytesToRead, --FromServer.Bytes'Last, --Message_Size,  -- size of the buffer
              NumberOfBytesRead   => toLPDWORD(BytesRead'address),
              Overlapped          => null ); -- not overlapped I/O
          if BytesRead > FromServer.Bytes'Last then --Message'size/8 then
            Text_IO.Put("Too many bytes read ");
            Int_IO.Put(Integer(BytesRead));
            Text_IO.Put_Line(" ");
 --         raise Program_Error;
          end if;
          if Status /= 0 then -- TRUE

                 --   DateTime localDate = DateTime.Now;
                 --   Console.WriteLine("ReceiveMessage {0}", localDate.Second);

--                    if (fromServer.Length < 14 + 8) // including NAKs //14)
            if FromServer.Count < Integer(Itf.HeaderSize) + 8 then --// including NAKs //14)
              Text_IO.Put("ERROR: Received less than "); --{0} bytes {1}",
              Int_IO.Put(Integer(Itf.HeaderSize));
              Text_IO.Put(" ");
              Int_IO.Put(Integer(FromServer.Count));
              Text_IO.Put_Line(" ");
       --                 for (int i = 0; i < fromServer.Length; i++)
       --                 {
       --                     Console.Write("{0} ", fromServer[i]);
       --                 }
       --                 Console.WriteLine(" ");
                        --> for 4 byte message, say 3 in a row, disconnect from
                        --  the remote app and force Receive to Connect again.
            end if;
            -- Remove any leading NAKs from message.
            Start := 0;
            for I in 1..FromServer.Count loop --Length loop
              if FromServer.Bytes(I) /= 21 then -- NAK
                Start := I;
                Exit; -- loop
              end if;
            end loop;

            declare
              J : Integer := 0;
              Msg : Itf.BytesType; --ByteArray(1..FromServer.Count - Start);
            begin
              for I in Start..FromServer.Count loop --Length loop
                Msg.Bytes(J) := FromServer.Bytes(I);
                J := J + 1;
              end loop;

              return Msg; -- fromServer; // line;
            end;
          end if;

        end;

      end if; -- IsConnected

    else -- no longer connected
      Text_IO.Put("ReceiveMessage not connected ");
      Int_IO.Put(Integer(RemoteAppId));
      Text_IO.Put_Line(" ");
      if PipeInfo(ReceiveIndex).Connected then -- was connected
        Text_IO.Put("ReceiveMessage calling Remote ");
        Int_IO.Put(Integer(RemoteAppId));
        Text_IO.Put_Line(" ");
        Remote.SetConnected(RemoteAppId,False); --.PipeConnected := False;
        PipeInfo(ReceiveIndex).Connected := False;
        ClosePipes(True); -- close receive pipe
      end if;
    end if;
--  end if;

    -- Return a null message if pipeClient is null.
    return ( Count => 0,
             Bytes => ( others => 0 ) );
--    return BitConverter.GetBytes(1);

  end ReceiveMessage;

  -- Transmit a message to the remote pipe server.
  procedure TransmitMessage
  ( Message : in Itf.BytesType --ByteArray
  ) is

    Status : ExecItf.BOOL;

    use type System.Address;

  begin -- TransmitMessage

    if PipeInfo(TransmitIndex).Handle /= ExecItf.Invalid_Handle_Value then

--                DateTime localDate = DateTime.Now;

--                Console.WriteLine("TransmitMessage {0}  Msg {1} {2} From {3} To {4} {5:G}",
--                                   pipeInfo[0].name, message[0],message[1],message[2],
--                                   message[5], localDate.Second);
      declare -- try

        BytesWritten
        -- Number of bytes written
        : ExecItf.DWORD;

        Msg : Itf.BytesType; --ByteArray(1..Message.Length+8);

        use type Interfaces.C.unsigned_long;

      begin
        -- Prepend 8 NAK's to the beginning of the message.
        for I in 1..8 loop
          Msg.Bytes(I) := 21; -- NAK
        end loop;
        -- Copy the message to follow the NAKs
        for I in 1..Message.Count loop --Length loop
          Msg.Bytes(I + 8) := Message.Bytes(I);
        end loop;
        Msg.Count := Message.Count + 8;

        -- Send message via the server process.
        Status := ExecItf.WriteFile
                  ( File                 => PipeInfo(TransmitIndex).Handle, -- handle to pipe
                    Buffer               => toLPVOID(Msg.Bytes'address), -- buffer to write from
 --                 nNumberOfBytesToWrite  => Exec_Itf.ULONG(Message.Header.Count+  --number of bytes to write
 --                                           Message_Data_Count_Type(Message_Header_Size)),
                    NumberOfBytesToWrite => ExecItf.ULONG(Msg.Count),                --number of bytes to write
                    NumberOfBytesWritten => toLPDWORD(BytesWritten'address), -- number of bytes written, an out parameter
                    Overlapped           => null ); -- not overlapped I/O


--        declare
 --         ss : StreamString := new StreamString(PipeServer);
--          Len : Integer := ss.WriteBytes(Msg.Count); --message);
--        begin
--         if Len /= Msg.Count + 2 then --Length + 2 then --message.Length + 2)
        if Integer(Status) > 0 then -- Write successful
          if Integer(BytesWritten) /= Msg.Count then --Length + 2 then --message.Length + 2)
            Text_IO.Put("ERROR: Write of wrong length ");
            Int_IO.Put(Integer(BytesWritten)); --Len);
            Text_IO.Put(" ");
            Int_IO.Put(Integer(Msg.Count)); --Length));
            Text_IO.Put_Line(" ");
          end if;
        else
          Text_IO.Put("ERROR: Write to pipe failed");
        end if;
 --       end;
      end;
    else
      Text_IO.Put_Line("ERROR: null pipeServer");
    end if;
    -- Catch the IOException that is raised if the pipe is broken
    -- or disconnected.
  exception -- catch (IOException e)
    when others =>
      Text_IO.Put("ERROR: "); --, e.Message);
      Text_IO.Put("Setting PipeConnected false for ");
      Int_IO.Put(Integer(RemoteAppId));
      Text_IO.Put_Line(" ");
      Remote.SetConnected(RemoteAppId,False);

  end TransmitMessage;

end NamedPipe;
